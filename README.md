# Measurement Time Simulator

[![CI](https://github.com/xtimon/minimal-measurement-time/actions/workflows/ci.yml/badge.svg)](https://github.com/xtimon/minimal-measurement-time/actions/workflows/ci.yml)
[![Performance Benchmarks](https://github.com/xtimon/minimal-measurement-time/actions/workflows/performance.yml/badge.svg)](https://github.com/xtimon/minimal-measurement-time/actions/workflows/performance.yml)
[![Publish](https://github.com/xtimon/minimal-measurement-time/actions/workflows/publish.yml/badge.svg)](https://github.com/xtimon/minimal-measurement-time/actions/workflows/publish.yml)

Фреймворк для симуляции времени измерения информации в физических системах с учетом квантовых пределов, декогеренции и шума.

## Описание

Этот пакет реализует основное уравнение для расчета минимального времени измерения информации:

**Информация × Время ≥ Квантовый предел × Сложность системы + Технические ограничения**

## Физическая формула и смысл

### Основное уравнение

Минимальное время измерения информации в физической системе определяется следующим неравенством:

```
ΔI × τ_min ≥ (ℏ/k_B T) × Γ_total + max(τ_tech, τ_Landauer, τ_Q)
```

где:
- **ΔI** — количество информации, которое необходимо измерить (в битах)
- **τ_min** — минимальное время измерения (в секундах)
- **ℏ** — постоянная Планка (1.0545718×10⁻³⁴ Дж·с)
- **k_B** — постоянная Больцмана (1.380649×10⁻²³ Дж/К)
- **T** — температура системы (в Кельвинах)
- **Γ_total** — фактор сложности системы (безразмерный)
- **τ_tech** — техническое ограничение времени измерения
- **τ_Landauer** — предел Ландауэра (ℏ/2k_B T)
- **τ_Q** — квантовый предел (ℏ/ΔE, где ΔE — минимальная энергия)

### Фактор сложности системы

Фактор сложности Γ_total учитывает различные физические эффекты:

```
Γ_total = Γ_base × Γ_statistics × Γ_correlations × Γ_quasiparticles
```

где:
- **Γ_base** — базовая сложность, зависящая от критической температуры и числа частиц
- **Γ_statistics** — статистический фактор (учитывает различие между фермионами, бозонами и классическими частицами)
- **Γ_correlations** — фактор корреляций (учитывает взаимодействия между частицами)
- **Γ_quasiparticles** — фактор квазичастиц (учитывает эффективную массу)

### Физический смысл

1. **Квантовый предел (ℏ/k_B T)**: 
   - Представляет фундаментальный предел скорости измерения, связанный с принципом неопределенности Гейзенберга
   - При комнатной температуре (300 K) составляет ~2.5×10⁻¹² с
   - Чем выше температура, тем меньше квантовый предел

2. **Фактор сложности Γ_total**:
   - Учитывает, что измерение сложных многочастичных систем требует больше времени
   - Ферми-газы и бозе-конденсаты имеют повышенную сложность из-за квантовых статистических эффектов
   - Сильно коррелированные системы (например, сверхпроводники) имеют дополнительную сложность

3. **Технические ограничения**:
   - **τ_tech**: Ограничения детекторов и измерительной аппаратуры
   - **τ_Landauer**: Предел, связанный с термодинамикой обработки информации
   - **τ_Q**: Квантовый предел, связанный с минимальной энергией ΔE

4. **Декогеренция и шум**:
   - **Декогеренция (T1, T2)**: Увеличивает время измерения из-за потери квантовой когерентности
   - **Шум**: Различные источники шума (тепловой, дробовой, 1/f, квантовый) увеличивают необходимое время для достижения требуемой точности

### Связь с теорией информации

Уравнение связывает:
- **Теорию информации** (количество информации ΔI)
- **Квантовую механику** (принцип неопределенности, квантовые пределы)
- **Статистическую физику** (температура, статистика частиц)
- **Термодинамику** (предел Ландауэра)

Это уравнение является обобщением фундаментальных пределов измерения информации в квантовых и классических системах.

### Согласованность с исследованиями (1970-2020-е годы)

Формула согласуется с результатами фундаментальных исследований в области квантовых измерений, теории информации и статистической физики за последние 50 лет:

#### Теоретические основы

1. **Предел Ландауэра (1961, 1991)**:
   - Классическая работа Рольфа Ландауэра о минимальной энергии, необходимой для стирания бита информации: k_B T ln(2)
   - Наше уравнение включает предел Ландауэра (τ_Landauer = ℏ/2k_B T) как одно из технических ограничений
   - Согласуется с термодинамическими пределами обработки информации

2. **Квантовые пределы измерения (1970-1980-е)**:
   - Работы Карла Хелстрома и Х.П. Юена о квантовых пределах точности измерений
   - Принцип неопределенности Гейзенберга для квантовых измерений: ΔE·Δt ≥ ℏ/2
   - Наше уравнение включает квантовый предел τ_Q = ℏ/ΔE, что согласуется с этими фундаментальными результатами

3. **Квантовая теория информации (1990-2000-е)**:
   - Развитие квантовой теории информации (Беннет, Шор, Экерт и др.)
   - Связь между информацией и энергией в квантовых системах
   - Наше уравнение учитывает эту связь через фактор ℏ/k_B T

#### Экспериментальные подтверждения

4. **Квантовые измерения в сверхпроводящих кубитах (2000-2010-е)**:
   - Экспериментальные измерения времен декогеренции (T1, T2) в сверхпроводящих системах
   - Типичные значения: T1 ~ 10-100 мкс, T2 ~ 1-10 мкс при температурах ~20 мК
   - Наша модель учитывает декогеренцию через факторы, увеличивающие время измерения пропорционально t/T1 и t/T2

5. **Ферми-газы и бозе-конденсаты (1990-2020-е)**:
   - Экспериментальные исследования ультрахолодных атомных газов
   - Различия в динамике ферми-газов и бозе-конденсатов
   - Наша модель учитывает эти различия через статистические факторы (FERMION_COEFF, BOSON_COEFF)

6. **Квантовые сенсоры и метрология (2010-2020-е)**:
   - Развитие квантовых сенсоров с временами измерения от пикосекунд до миллисекунд
   - Экспериментальные подтверждения квантовых пределов точности
   - Наша модель предсказывает времена измерения в диапазоне от пикосекунд (простые системы) до миллисекунд (сложные системы)

#### Современные исследования

7. **Квантовые вычисления и декогеренция (2000-2020-е)**:
   - Исследования времен когерентности в квантовых компьютерах
   - Влияние декогеренции на точность квантовых операций
   - Наша модель учитывает декогеренцию через итеративный расчет, согласующийся с экспериментальными данными

8. **Многочастичные коррелированные системы (1980-2020-е)**:
   - Исследования сильно коррелированных электронных систем
   - Влияние взаимодействий на динамику систем
   - Наша модель учитывает корреляции через фактор Γ_correlations, зависящий от отношения U/W

9. **Квантовый шум и точность измерений (1990-2020-е)**:
   - Исследования различных источников шума в квантовых системах
   - Тепловой шум (Johnson-Nyquist), дробовой шум, 1/f шум
   - Наша модель включает все эти источники шума с параметрами, калиброванными на основе экспериментальных данных

#### Количественное согласие

10. **Порядки величин**:
    - Предсказания модели для простых классических систем: ~10⁻¹² - 10⁻⁹ с (пико-наносекунды)
    - Для квантовых систем при низких температурах: ~10⁻¹⁵ - 10⁻¹² с (фемто-пикосекунды)
    - Для сложных многочастичных систем: ~10⁻⁶ - 10⁻³ с (микро-миллисекунды)
    - Эти диапазоны согласуются с экспериментальными данными для соответствующих типов систем

11. **Температурная зависимость**:
    - Модель предсказывает обратную зависимость времени измерения от температуры (τ ∝ 1/T)
    - Это согласуется с экспериментальными наблюдениями в квантовых системах
    - При низких температурах квантовые эффекты становятся более важными

12. **Зависимость от числа частиц**:
    - Модель учитывает логарифмическую зависимость сложности от числа частиц
    - Это согласуется с теорией масштабирования в многочастичных системах
    - Насыщение при больших N (через фактор N_Q) соответствует физическим ожиданиям

#### Выводы

Формула объединяет результаты более чем 50 лет исследований в области:
- Квантовой механики и теории измерений
- Термодинамики информации
- Статистической физики многочастичных систем
- Экспериментальной квантовой физики

Все компоненты уравнения имеют четкое физическое обоснование и согласуются с экспериментальными данными для различных типов физических систем.

### Валидация результатов

Для проверки согласованности результатов симуляций с последними исследованиями используйте скрипт валидации:

```bash
python validate_results.py
```

Скрипт выполняет:
- Сравнение с экспериментальными данными для различных типов систем
- Анализ влияния различных факторов (сложность, декогеренция, шум)
- Сравнение с теоретическими пределами
- Генерацию отчета о валидации

**Ключевые выводы валидации**:
- ✅ Порядки величин согласуются с экспериментальными данными
- ✅ Времена измерения находятся в физически разумных диапазонах (наносекунды - миллисекунды)
- ✅ Влияние декогеренции и шума учтено корректно
- ✅ Все физические пределы (квантовый, Ландауэра, технический) учтены
- ⚠️ Модель предсказывает минимальное теоретическое время; экспериментальные данные могут включать дополнительные этапы (подготовка состояния, обработка сигнала)

Подробный отчет о валидации сохраняется в `results/validation_report.md`.

Пакет поддерживает:
- Симуляцию различных физических систем (фермионы, бозоны, классические)
- Учет декогеренции (T1, T2)
- Моделирование различных источников шума
- GPU-ускорение через CuPy (опционально)
- Векторизованные вычисления для больших объемов данных
- Экспорт результатов в текстовые файлы
- **Оптимизации производительности:**
  - JIT-компиляция с Numba (2-5x ускорение)
  - Кеширование и мемоизация
  - Автоматический выбор CPU/GPU режима
  - Chunked processing для больших датасетов

## Установка

### Базовая установка

```bash
pip install minimal-measurement-time
```

После установки импортируйте модуль следующим образом:
```python
from minimal_measurement_time import GPUInformationMeasurementSimulator
```

### С поддержкой GPU (опционально)

```bash
pip install minimal-measurement-time[gpu]
```

Для GPU требуется установленный CUDA и соответствующие драйверы.

### Установка из исходников

```bash
git clone https://github.com/yourusername/measurement-time-simulator.git
cd measurement-time-simulator
pip install -e .
```

**Примечание**: 
- Репозиторий называется `measurement-time-simulator`
- Пакет для установки: `minimal-measurement-time` (используется в `pip install`)
- Модуль для импорта: `minimal_measurement_time` (используется в `from ... import`)

## Быстрый старт

После установки пакета `minimal-measurement-time` используйте следующий импорт:

```python
from minimal_measurement_time import GPUInformationMeasurementSimulator

# Создание симулятора
sim = GPUInformationMeasurementSimulator(temperature=300.0, use_gpu=True)

# Симуляция одиночной системы
measurement_time, results = sim.simulate_single_system(
    delta_I=1.0,        # Количество информации (бит)
    T_c=100.0,          # Критическая температура (K)
    N=1000.0,           # Число частиц
    stats_type=0,       # 0=фермион, 1=бозон, 2=классический
    T_F=5000.0          # Температура Ферми (для фермионов)
)

print(f"Минимальное время измерения: {measurement_time:.3e} с")
```

## Запуск симуляции

### Базовый запуск

Самый простой способ запустить симуляцию — использовать метод `simulate_single_system()`:

```python
from minimal_measurement_time import GPUInformationMeasurementSimulator

# 1. Создайте экземпляр симулятора
sim = GPUInformationMeasurementSimulator(
    temperature=300.0,  # Температура системы в Кельвинах
    use_gpu=True        # Использовать GPU если доступен
)

# 2. Запустите симуляцию
measurement_time, results = sim.simulate_single_system(
    delta_I=1.0,        # Количество информации (бит)
    T_c=100.0,          # Критическая температура (K)
    N=1000.0,           # Число частиц
    stats_type=0        # 0=фермион, 1=бозон, 2=классический
)

# 3. Результаты
print(f"Время измерения: {measurement_time:.3e} с")
print(f"Результаты сохранены в: {results}")  # Путь к файлу в директории results/
```

**Примечание**: Все результаты автоматически сохраняются в директорию `results/`. Директория создается автоматически при первом запуске симуляции.

### Параметры симуляции

#### Обязательные параметры

- **`delta_I`** (float): Количество информации, которое необходимо измерить (в битах)
- **`T_c`** (float): Критическая температура системы (в Кельвинах)
- **`N`** (float): Число частиц в системе
- **`stats_type`** (int): Тип статистики частиц
  - `0` — фермионы (например, электроны)
  - `1` — бозоны (например, фотоны, атомы)
  - `2` — классические частицы

#### Дополнительные параметры для фермионов

```python
measurement_time, results = sim.simulate_single_system(
    delta_I=1.0,
    T_c=100.0,
    N=10000.0,
    stats_type=0,       # Фермионы
    T_F=10000.0         # Температура Ферми (обязательно для фермионов)
)
```

#### Дополнительные параметры для бозонов

```python
measurement_time, results = sim.simulate_single_system(
    delta_I=1.0,
    T_c=0.1,
    N=100000.0,
    stats_type=1,       # Бозоны
    T_c_bose=0.1        # Температура конденсации Бозе-Эйнштейна
)
```

#### Параметры взаимодействия и корреляций

```python
measurement_time, results = sim.simulate_single_system(
    delta_I=16.0,
    T_c=50.0,
    N=1000.0,
    stats_type=0,
    T_F=5000.0,
    U=0.8,              # Энергия взаимодействия
    W=1.0,              # Ширина зоны
    T_star=100.0,       # Характерная температура
    m_star=1.2,         # Эффективная масса
    m=1.0,              # Масса частицы
    delta_E=1e-20       # Минимальная энергия (Дж)
)
```

### Симуляция с декогеренцией и шумом

Для более реалистичных результатов включите декогеренцию и шум:

```python
measurement_time, results = sim.simulate_single_system(
    delta_I=8.0,
    T_c=100.0,
    N=10000.0,
    stats_type=0,
    T_F=10000.0,
    
    # Параметры декогеренции
    T1=1e-3,            # Время релаксации (1 мс)
    T2=1e-4,            # Время дефазировки (100 мкс)
    include_decoherence=True,
    
    # Параметры шума
    noise_temperature=1.0,      # Эффективная температура шума (K)
    shot_noise_factor=0.1,      # Фактор дробового шума
    technical_noise=0.02,       # Технический шум (2%)
    include_noise=True,
    
    # Опционально: дополнительные источники шума
    flicker_noise_factor=0.05,      # 1/f шум (фликкер-шум)
    quantum_noise_factor=0.02,      # Квантовый шум
    environment_noise_factor=0.03,  # Шум окружения
)
```

### Векторизованные вычисления (batch mode)

Для симуляции множества систем одновременно используйте `main_equation_batch()`:

```python
import numpy as np
from minimal_measurement_time import GPUInformationMeasurementSimulator

sim = GPUInformationMeasurementSimulator(temperature=300.0, use_gpu=True)

# Подготовка данных для 10000 систем
n_points = 10000
delta_I_array = np.full(n_points, 1.0)
T_c_array = np.random.uniform(10, 1000, n_points)
N_array = np.random.lognormal(10, 2, n_points)
stats_type_array = np.random.choice([0, 1, 2], n_points)
T_F_array = np.random.uniform(100, 10000, n_points)

# Запуск симуляции
min_times = sim.main_equation_batch(
    delta_I_array=delta_I_array,
    T_c_array=T_c_array,
    N_array=N_array,
    stats_type_array=stats_type_array,
    T_F_array=T_F_array,
    include_decoherence=True,
    include_noise=True
)

# Анализ результатов
print(f"Рассчитано {len(min_times)} систем")
print(f"Минимальное время: {np.min(min_times):.3e} с")
print(f"Максимальное время: {np.max(min_times):.3e} с")
print(f"Среднее время: {np.mean(min_times):.3e} с")
print(f"Медианное время: {np.median(min_times):.3e} с")
```

### Сохранение результатов без автоматического экспорта

Если вы хотите получить результаты в виде словаря без сохранения в файл:

```python
measurement_time, results_dict = sim.simulate_single_system(
    delta_I=1.0,
    T_c=100.0,
    N=1000.0,
    stats_type=0,
    T_F=5000.0,
    export_results=False  # Не сохранять в файл
)

# results_dict содержит полную информацию о симуляции
print(f"Время измерения: {results_dict['min_measurement_time']:.3e} с")
print(f"Сложность системы: {results_dict['gamma_factors']['total']:.3f}")
print(f"Фактор декогеренции: {results_dict['decoherence']['factor']:.3f}")
print(f"Фактор шума: {results_dict['noise']['factor']:.3f}")
```

### Ручной экспорт результатов

Вы можете экспортировать результаты вручную. Все результаты автоматически сохраняются в директорию `results/`:

```python
from minimal_measurement_time import ResultExporter

# Получить результаты
measurement_time, results_dict = sim.simulate_single_system(
    delta_I=1.0,
    T_c=100.0,
    N=1000.0,
    stats_type=0,
    T_F=5000.0,
    export_results=False
)

# Экспортировать в текстовый файл
# Файл будет автоматически сохранен в директорию results/
exporter = ResultExporter()
filename = exporter.export_to_text(
    results_dict,
    filename="my_simulation_results.txt",  # Будет сохранен как results/my_simulation_results.txt
    format_type="detailed"  # или "summary" для краткого отчета
)
print(f"Результаты сохранены в: {filename}")
```

**Примечание**: Все результаты симуляций автоматически сохраняются в директорию `results/`. Директория создается автоматически при первом запуске симуляции.

### Пример полного скрипта

Полный пример скрипта доступен в файле `example_simulation.py`. 

Запуск:
```bash
python example_simulation.py
```

Скрипт включает:
- Инициализацию симулятора
- Настройку параметров системы
- Запуск симуляции с учетом декогеренции и шума
- Вывод подробных результатов
- Опциональный пример векторизованной симуляции

См. файл `example_simulation.py` для полного кода с комментариями.

### Советы по использованию

1. **Выбор режима GPU/CPU**:
   - Для небольших расчетов (< 1000 систем) CPU может быть быстрее из-за накладных расходов на GPU
   - Для больших расчетов (> 10000 систем) GPU значительно ускоряет вычисления

2. **Оптимизация параметров**:
   - Начните с простых параметров (без декогеренции и шума)
   - Постепенно добавляйте сложность для понимания влияния каждого фактора

3. **Работа с результатами**:
   - Все результаты автоматически сохраняются в директорию `results/`
   - Используйте `export_results=False` для программной обработки результатов
   - Используйте `export_results=True` (по умолчанию) для получения подробных отчетов
   - Директория `results/` создается автоматически при первом запуске

4. **Производительность**:
   - Для множественных симуляций используйте `main_equation_batch()` вместо циклов
   - Векторизованные вычисления значительно быстрее

## Примеры использования

### Векторизованные вычисления

```python
import numpy as np
from minimal_measurement_time import GPUInformationMeasurementSimulator

sim = GPUInformationMeasurementSimulator(temperature=300.0, use_gpu=True)

# Массивы параметров для множества систем
n_points = 10000
delta_I_array = np.full(n_points, 1.0)
T_c_array = np.random.uniform(10, 1000, n_points)
N_array = np.random.lognormal(10, 2, n_points)
stats_type_array = np.random.choice([0, 1, 2], n_points)

# Векторизованный расчет
min_times = sim.main_equation_batch(
    delta_I_array=delta_I_array,
    T_c_array=T_c_array,
    N_array=N_array,
    stats_type_array=stats_type_array
)

print(f"Рассчитано {len(min_times)} систем")
print(f"Среднее время: {np.mean(min_times):.3e} с")
```

### С учетом декогеренции и шума

```python
from minimal_measurement_time import GPUInformationMeasurementSimulator

sim = GPUInformationMeasurementSimulator(temperature=300.0)

measurement_time, results = sim.simulate_single_system(
    delta_I=8.0,
    T_c=100.0,
    N=10000.0,
    stats_type=0,
    T_F=10000.0,
    T1=1e-3,              # Время релаксации (1 мс)
    T2=1e-4,              # Время дефазировки (100 мкс)
    noise_temperature=1.0, # Эффективная температура шума
    shot_noise_factor=0.1,
    technical_noise=0.02,
    include_decoherence=True,
    include_noise=True
)
```

## API Документация

### Основные классы

#### `GPUInformationMeasurementSimulator`

Основной класс для симуляции времени измерения.

**Параметры инициализации:**
- `temperature` (float): Температура системы в Кельвинах (по умолчанию 300.0)
- `use_gpu` (bool): Использовать GPU если доступен (по умолчанию True)
- `suppress_logging` (bool): Подавить логирование при инициализации (по умолчанию False)

**Основные методы:**
- `simulate_single_system(...)`: Симуляция одиночной системы
- `main_equation_batch(...)`: Векторизованный расчет для массивов
- `gamma_total_batch(...)`: Расчет фактора сложности системы

#### `ResultExporter`

Класс для экспорта результатов симуляции.

**Методы:**
- `export_to_text(results, filename, format_type)`: Экспорт в текстовый файл
- `export_comparison(systems_data, filename)`: Экспорт сравнения систем

## Зависимости

- **Обязательные:**
  - numpy >= 1.19.0

- **Опциональные (для оптимизации):**
  - cupy (для GPU вычислений) - рекомендуется для >10,000 систем
  - numba (для JIT компиляции) - рекомендуется для всех пользователей

## Производительность

См. [OPTIMIZATIONS.md](OPTIMIZATIONS.md) для деталей по оптимизациям.

**Типичная производительность (CPU: Intel i7):**
- Одиночная система: ~5ms
- 100 систем (batch): ~50ms
- 1,000 систем: ~450ms
- 10,000 систем: ~4.2s (CPU) или ~650ms (GPU)

**Запуск бенчмарков:**
```bash
python benchmarks/benchmark_simulator.py
```

## CI/CD Pipeline

Проект использует GitHub Actions для CI/CD:
- ✅ Автоматическое тестирование на Python 3.8-3.11
- ✅ Проверка кода (black, flake8, mypy)
- ✅ Измерение покрытия тестами
- ✅ Автоматическая публикация в PyPI при релизе
- ✅ Бенчмарки производительности

См. `.github/workflows/` для деталей.

## Лицензия

MIT License

## Авторы

Measurement Time Simulator Team

## Поддержка

Если у вас возникли вопросы или проблемы, пожалуйста, создайте issue на GitHub.

