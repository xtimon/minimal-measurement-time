# План симуляций для анализа

Этот документ описывает систему для создания и выполнения комплексного плана симуляций для всех сред с различными параметрами.

## Обзор

Система состоит из двух основных скриптов:

1. **`simulation_plan.py`** - Генерация и выполнение плана симуляций
2. **`analyze_simulation_results.py`** - Анализ результатов симуляций

## Структура плана симуляций

План включает симуляции для всех типов физических систем:

### 1. Фермионы (stats_type=0)
- **Параметры:**
  - Количество бит (ΔI): 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024
  - Количество частиц (N): 10², 10³, 10⁴, 10⁵, 10⁶, 10⁷
  - Температура системы (T): 0.01, 0.1, 1.0, 10.0, 100.0, 300.0, 1000.0 K
  - Критическая температура (T_c): 10, 50, 100, 500, 1000, 5000, 10000 K
  - Температура Ферми (T_F): 100, 500, 1000, 5000, 10000, 50000 K
  - Энергия взаимодействия (U): 0.0, 0.1, 0.3, 0.5, 0.7, 0.9
  - Ширина зоны (W): 0.5, 1.0, 2.0, 5.0
  - Времена декогеренции (T1, T2): различные значения

### 2. Бозоны (stats_type=1)
- **Параметры:**
  - Количество бит (ΔI): 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024
  - Количество частиц (N): 10², 10³, 10⁴, 10⁵, 10⁶, 10⁷
  - Температура системы (T): 0.01, 0.1, 1.0, 10.0, 100.0, 300.0, 1000.0 K
  - Критическая температура (T_c): 0.001, 0.01, 0.1, 1.0, 10.0, 100.0 K
  - Температура конденсации (T_c_bose): обычно равна T_c
  - Энергия взаимодействия (U): 0.0, 0.1, 0.3, 0.5, 0.7, 0.9
  - Ширина зоны (W): 0.5, 1.0, 2.0, 5.0
  - Времена декогеренции (T1, T2): различные значения

### 3. Классические системы (stats_type=2)
- **Параметры:**
  - Количество бит (ΔI): 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024
  - Количество частиц (N): 10², 10³, 10⁴, 10⁵, 10⁶, 10⁷
  - Температура системы (T): 0.01, 0.1, 1.0, 10.0, 100.0, 300.0, 1000.0 K
  - Критическая температура (T_c): 10, 50, 100, 300, 500, 1000 K
  - Энергия взаимодействия (U): 0.0, 0.1, 0.3, 0.5, 0.7, 0.9
  - Ширина зоны (W): 0.5, 1.0, 2.0, 5.0

## Использование

### Шаг 1: Генерация и выполнение плана симуляций

```bash
python simulation_plan.py
```

Скрипт выполнит следующие действия:

1. **Генерация плана** - создание всех комбинаций параметров
2. **Сохранение плана** - сохранение плана в JSON файл
3. **Выполнение симуляций** - запуск симуляций (можно ограничить количество для тестирования)
4. **Сохранение результатов** - сохранение результатов в JSON файл

**Важно:** Полный план может содержать десятки тысяч симуляций. Для тестирования рекомендуется ограничить количество:

```python
# В интерактивном режиме скрипт спросит количество симуляций
# Или можно изменить код напрямую:
plan.execute_plan(max_simulations=100)  # Только 100 симуляций для теста
```

### Шаг 2: Анализ результатов

После выполнения симуляций, проанализируйте результаты:

```bash
python analyze_simulation_results.py results/simulation_plan/final_results_YYYYMMDD_HHMMSS.json
```

Скрипт создаст:

1. **Графики:**
   - `by_stats_type.png` - Распределение времен по типам систем
   - `vs_delta_I.png` - Зависимость от количества бит
   - `vs_N.png` - Зависимость от количества частиц
   - `vs_temperature.png` - Зависимость от температуры
   - `correlations.png` - Корреляции между параметрами

2. **Отчет:**
   - `analysis_report_YYYYMMDD_HHMMSS.md` - Детальный текстовый отчет

## Структура результатов

### Файлы плана

План сохраняется в `results/simulation_plan/simulation_plan_YYYYMMDD_HHMMSS.json`:

```json
[
  {
    "stats_type": 0,
    "delta_I": 8.0,
    "N": 10000.0,
    "temperature": 300.0,
    "T_c": 100.0,
    "T_F": 10000.0,
    "U": 0.5,
    "W": 1.0,
    "description": "Фермион: ΔI=8, N=1e+04, T=300K, T_c=100K, T_F=10000K"
  },
  ...
]
```

### Файлы результатов

Результаты сохраняются в `results/simulation_plan/final_results_YYYYMMDD_HHMMSS.json`:

```json
[
  {
    "config": { ... },
    "measurement_time": 1.234e-9,
    "gamma_total": 2.456,
    "decoherence_factor": 1.123,
    "noise_factor": 1.456,
    "min_measurement_time_ideal": 8.901e-10
  },
  ...
]
```

## Оптимизация выполнения

### Параллельная обработка (CPU)

По умолчанию скрипт автоматически использует все доступные ядра процессора для параллельной обработки:

```python
# Автоматически использует все ядра
plan.execute_plan(max_simulations=None, use_gpu=False, n_jobs=None)

# Указать конкретное количество процессов
plan.execute_plan(max_simulations=None, use_gpu=False, n_jobs=8)
```

**Важно:** Параллельная обработка работает только для CPU. При использовании GPU (`use_gpu=True`) выполнение происходит последовательно, так как GPU не может использоваться в нескольких процессах одновременно.

### Использование GPU

Для ускорения больших симуляций можно использовать GPU (но без параллелизма):

```python
plan.execute_plan(max_simulations=None, use_gpu=True)
```

**Рекомендация:** Для больших планов симуляций рекомендуется использовать CPU с параллельной обработкой, так как это позволяет использовать все ядра процессора одновременно.

### Промежуточное сохранение

Результаты автоматически сохраняются каждые 100 симуляций, чтобы не потерять данные при прерывании:

```python
plan.execute_plan(save_every=100)  # Сохранять каждые 100 симуляций
```

### Пакетная обработка

Для очень больших планов можно разбить выполнение на части:

```python
# Первая часть
plan.execute_plan(max_simulations=1000, use_gpu=True)

# Вторая часть (после загрузки предыдущих результатов)
# ... загрузить и объединить результаты ...
```

## Примеры использования

### Пример 1: Быстрый тест

```bash
# Запустить только 50 симуляций для проверки
python simulation_plan.py
# При запросе ввести: 50
```

### Пример 2: Полный план для одной среды

Можно модифицировать `simulation_plan.py` для выполнения только одной среды:

```python
# В методе generate_plan() закомментировать ненужные среды
# Например, только фермионы:
plan.extend(fermion_configs)
# plan.extend(boson_configs)  # Закомментировано
# plan.extend(classical_configs)  # Закомментировано
```

### Пример 3: Анализ конкретного параметра

```python
from analyze_simulation_results import SimulationAnalyzer

analyzer = SimulationAnalyzer("results/simulation_plan/final_results_...json")

# Анализ зависимости от количества бит
analysis = analyzer.analyze_by_parameter("delta_I")
print(analysis["stats_by_value"])
```

## Зависимости

Для анализа результатов требуется:

```bash
pip install matplotlib numpy
```

## Производительность

**Оценка времени выполнения:**

- Одна симуляция: ~5-50 мс (зависит от параметров)
- 100 симуляций: ~0.5-5 секунд
- 1000 симуляций: ~5-50 секунд
- 10000 симуляций: ~1-10 минут (CPU) или ~10-100 секунд (GPU)

**Рекомендации:**

- Для тестирования: 50-100 симуляций
- Для полного анализа: все симуляции (может занять несколько часов)
- Используйте GPU для ускорения больших планов

## Вопросы и поддержка

При возникновении проблем:

1. Проверьте, что все зависимости установлены
2. Убедитесь, что есть достаточно места на диске для результатов
3. Для больших планов используйте промежуточное сохранение
4. Проверьте логи ошибок в консоли

## Дальнейший анализ

После получения результатов можно:

1. Использовать Python для дополнительного анализа:
   ```python
   import json
   import numpy as np
   
   with open("results/simulation_plan/final_results_...json") as f:
       results = json.load(f)
   
   # Ваш анализ...
   ```

2. Экспортировать данные в другие форматы (CSV, Excel) для анализа в других инструментах

3. Создать дополнительные визуализации с помощью matplotlib или других библиотек


